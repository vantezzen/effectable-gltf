---
title: Creating Custom Effects
description: Learn how to create custom effects for your glTF models
nav: 3
---

While effectable-gltf comes with two built-in effects, you can create your own custom effects by following the same pattern. This guide will show you how to create custom effects using the same hooks and patterns as the built-in effects.

## Effect Structure

Custom effects in effectable-gltf are React components that use the `useEffectData` hook to access the model's data. Here's the basic structure:

```tsx
import { type FC } from "react";
import { useEffectData } from "@vantezzen/effectable-gltf";

interface MyCustomEffectProps {
  // Define your effect's props here
  someProp?: string;
}

export const MyCustomEffect: FC<MyCustomEffectProps> = ({ someProp }) => {
  const { root, meshes } = useEffectData();

  // Your effect implementation here

  return null;
};
```

## Example: Creating a Simple Color Effect

Let's create a simple effect that changes the color of all meshes in the model. This example follows the same pattern as the `OverlayEffect`:

```tsx
import { type FC, useEffect, useRef } from "react";
import { type ColorRepresentation, Mesh, MeshStandardMaterial } from "three";
import { useEffectData } from "@vantezzen/effectable-gltf";

interface ColorEffectProps {
  color: ColorRepresentation;
}

export const ColorEffect: FC<ColorEffectProps> = ({ color }) => {
  const { meshes } = useEffectData();
  const clonesRef = useRef<Mesh[]>([]);

  // Create clones of the meshes with the new color
  useEffect(() => {
    const clones: Mesh[] = [];

    meshes.forEach((mesh) => {
      const clone = mesh.clone() as Mesh;
      const mat = (clone.material as MeshStandardMaterial).clone();

      mat.color.set(color);
      clone.material = mat;
      clone.raycast = () => null; // Optional: prevent raycasting on the clone

      (mesh.parent ?? mesh).add(clone);
      clones.push(clone);
    });

    clonesRef.current = clones;

    // Cleanup function
    return () => {
      clones.forEach((c) => {
        c.parent?.remove(c);
        (c.material as MeshStandardMaterial).dispose();
      });
      clonesRef.current = [];
    };
  }, [meshes]);

  // Update color when it changes
  useEffect(() => {
    clonesRef.current.forEach((c) => {
      const mat = c.material as MeshStandardMaterial;
      mat.color.set(color);
      mat.needsUpdate = true;
    });
  }, [color]);

  return null;
};
```

## Example: Creating a Post-Processing Effect

You can also create effects that use Three.js post-processing, similar to the `OutlineEffect`:

```tsx
import { type FC } from "react";
import { type ColorRepresentation } from "three";
import { EffectComposer, BloomEffect } from "@react-three/postprocessing";
import { useEffectData } from "@vantezzen/effectable-gltf";

interface BloomEffectProps {
  intensity?: number;
  luminanceThreshold?: number;
}

export const CustomBloomEffect: FC<BloomEffectProps> = ({
  intensity = 1,
  luminanceThreshold = 0.9,
}) => {
  const { meshes } = useEffectData();
  if (!meshes.length) return null;

  return (
    <EffectComposer autoClear={false} multisampling={8}>
      <BloomEffect
        selection={meshes}
        intensity={intensity}
        luminanceThreshold={luminanceThreshold}
      />
    </EffectComposer>
  );
};
```

## Using Your Custom Effect

Once you've created your custom effect, you can use it just like the built-in effects:

```tsx
import { EffectableGltf } from "@vantezzen/effectable-gltf";
import { ColorEffect } from "./ColorEffect";

function MyScene() {
  return (
    <EffectableGltf src="/path/to/model.gltf">
      <ColorEffect color="blue" />
    </EffectableGltf>
  );
}
```

## Best Practices

1. **Cleanup**: Always clean up your effects when they unmount

   - Remove any added meshes
   - Dispose of any created materials
   - Remove any event listeners

2. **Performance**: Consider performance implications

   - Use `useRef` to store references to created objects
   - Avoid unnecessary re-renders
   - Clean up resources properly

3. **TypeScript**: Use proper types

   - Define prop interfaces
   - Use proper Three.js types
   - Handle null cases

4. **Error Handling**: Handle edge cases
   - Check if meshes exist
   - Handle material type mismatches
   - Provide fallbacks when needed

## Next Steps

- Check out the [API Reference](./api-reference) for more details about the available hooks and types
- Look at the source code of [OverlayEffect](https://github.com/vantezzen/effectable-gltf/blob/main/lib/OverlayEffect.tsx) and [OutlineEffect](https://github.com/vantezzen/effectable-gltf/blob/main/lib/OutlineEffect.tsx) for more examples
